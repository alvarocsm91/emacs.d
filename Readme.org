* Introducción
# Comandos org para la exportación como *.pdf de este archivo.
#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+options: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+title: Readme
#+date: \today
#+author: Álvaro Cortés Sánchez-Migallón
#+email: alvarocsm.91@gmail.com
#+language: es
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.0.50 (Org mode 9.3.6)
#+latex_class: article
#+latex_class_options:
#+latex_header:
#+latex_header_extra:
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: pdflatex

  Este documento es la guia para poder configurar emacs con mi propia
  configuración, yo lo utilizo por ahora en mi ordenador sobre Fedora 31. La
  versión que utilizo de emacs es la actual, intentando tener la última que
  suele solucionar los errores detectados. Emacs 28.0.50 (Org mode 9.3.6)

  Desde este archivo se pueden exportar los fragmentos de código para generar el
  script que leerá Emacs para realizar la configuración, este archivo es
  /init.el/ y se añade en el repositorio.

* Configuración básica

  En este apartado de configuran elementos básicos del sistema, sirve de ayuda
  para poder realizar la lectura de variables de entorno del sistema o cargar
  hasta el inicio de los repositorios donde se encuentran los paquetes que
  posteriormente descargaremos para su uso.

  Para poder realizar la localización de distintos archivos se genera la
  variable que apunte a la raíz del sistema, para ello se extrae el valor de la
  variable de entorno /HOME/.

  #+begin_src lisp :tangle init.el
    ;;; Basic setup
    ;;;; Home directory
    (setq MyHomeDir (getenv "HOME"))
  #+end_src

  Para la conexión a Internet desde detrás de un proxy se prueba a ver si se
  tiene un fichero de configuración del proxy, mostrado a continuación.

  #+begin_src lisp :tangle init.el
    ;;;; Proxy
    (when (file-exists-p (format "%s/.emacs.d/proxy.el" MyHomeDir))
      (load-file (format "%s/.emacs.d/proxy.el" MyHomeDir)))
  #+end_src

  Para poder hacer uso de los ditintos paquetes es necesario cargar los
  repositorios se utilizarán los paquetes de melpa, basado en paquetes no
  oficiales soportados en git para el control de sus versiones. Se define la
  carpeta de carga dentro de la carpeta /.emacs.d/, se descararán las últimas
  versiones, por último se cargan los repositorios y se refrescan los contenidos.

  #+begin_src lisp :tangle init.el
    ;;;; Repositories
    (require 'package)
    (setq package-user-dir (format "%s/.emacs.d/elpa" MyHomeDir))

    (setq load-prefer-newer t
          package-enable-at-startup t)

    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
    (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)

    (package-initialize)
    (package-refresh-contents)
  #+end_src

* Instalación de paquetes

  Una de las grandes ventajas que tiene emacs es que se pueden añadir fácilmente
  distintos paquetes y con ello funcionalidades que permiten hacer tu vida más
  facil a la hora de conseguir tus metas.

  Para la instalación de paquetes es recomendable utilizar la función
  /use-package/ que permite realizar una auto carga de la última actualización
  de los distintos paquetes que se utilicen en el sistema, descargandolos y
  compilandolos para poder ser utilizados.

  #+begin_src lisp :tangle init.el
    ;;; Package usage
    ;;;; Use Package
    (package-install 'use-package t)
    (setq use-package-always-defer t
          use-package-always-ensure t)
  #+end_src

  También se puede utilizar el comando /require/ para las mismas funciones.

  Para más información [[https://github.com/jwiegley/use-package][use-package]].

** Hydra

   El paquete de hydra es muy importante en esta configuración ya que premite
   acortar los comandos para llamar funciones, al utilizar muchos y muy diversos
   paquete, permite crear combinaciones de comandos.

   #+begin_src lisp :tangle init.el
     ;;;; Hydra
     (use-package hydra
       :defer t)
   #+end_src

   Para más información [[https://github.com/abo-abo/hydra][hydra]].

** Org

   Org es uno de los modos de trabajo más importantes de emacs, ya que permite
   muchisimas cosas entre ellas trabajar de forma organizada, generando
   documentos con código para exportar a partir de software libre como emacs
   dejando los documentos elegantes y comprensibles. Se tuiliza también para la
   gestión de tareas por llevar a cabo y es muy utilizado gracias a la mezcla de
   sus funcionalidades con otros paquetes.

   #+begin_src lisp :tangle init.el
     ;;;; Org mode
     (use-package org
       :ensure org-plus-contrib
       :config
       (setq org-return-follows-link t)
       :hook (org-mode . (lambda ()
                           (aggressive-fill-paragraph-mode t)))
       :bind
       (("C-x L" . org-store-link)		;; global
        ("C-x C-l" . org-insert-link-global) ;; global
        :map org-mode-map
        ("C-x C-l" . org-insert-link)))
   #+end_src

   Para la gestión de tareas se han definido los siguientes estados de la tareas
   en las que las tareas empiezan como ideas para ser definidas /TBD/ pasando a
   por hacer cuando se ha generado la planificación de la misma con /TODO/. Una
   vez se han iniciado se manienen en modo /ACTIVE/ o /BLOCKED/ en función de si
   estamos trabajando o no en este mismo momento. Por último, la tarea se define
   como completa con los atributos de /DONE/ y /ARCHIVED/ para cuando las tareas
   han sido terminadas y cerradas y el atributo de DELETED por si al final se ha
   decidido no hacer, estos tres marcan la tarea como completa.

   #+begin_src lisp :tangle init.el
     ;;;;; Org tarsk state
     ;;Define pocess states
     (setq org-todo-keywords
     '((sequence "TBD" "TODO" "ACTIVE" "BLOCKED" "REVIEW" "|" "DONE" "ARCHIVED" "DELETED")))
     ;; Define process colours
     (setq org-todo-keyword-faces
           '(("TBD" .(:foreground "white" :weight bold-italic))
           ("TODO" .(:foreground "grey" :weight bold-italic))
           ("ACTIVE" .(:foreground "ligth-blue" :weight bold-italic))
           ("BLOCKED" .(:foreground "purple" :weight bold-italic))
           ("REVIEW" .(:foreground "pink" :weight bold-italic))
           ("DONE" .(:foreground "yellow" :weight bold-italic))
           ("ARCHIVED" .(:foreground "green" :weight bold-italic))
           ("DELETED" .(:foreground "black" :weight bold-italic))))
   #+end_src

   Para la exportación de documentación en latex y el uso de los colores de la
   tablera de colores de los modos de programación soportados en org se utiliza
   la herramienta /pygmentize/ que hay que instalar previamente en nuestro
   terminal.

   #+begin_src lisp :tangle init.el
     ;;;;; Org pygmentize
     (require 'org)
     (require 'ox-latex)
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     (setq org-latex-listings 'minted)

     (setq org-latex-pdf-process
           '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
         "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
         "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

     (setq org-src-fontify-natively t)

     (org-babel-do-load-languages
      'org-babel-load-languages
      '((R . t)
        (latex . t)
        ()))
   #+end_src

   Para más información [[https://orgmode.org/][org-mode]].

** Org-link-minor-mode

   Se trata de un modo menor de emacs, permite el uso del modo org y la
   activación de sus links desde modos distintos al org, como puedan ser los
   modos de programación, es muy útil para su uso en links a documentación
   relativa desde el mismo archivo.

   Antes de utilizarlo se debe clonar el paquete de github:

   #+begin_src shell
     $ git clone https://github.com/seanohalpin/org-link-minor-mode.git
   #+end_src

   #+begin_src lisp :tangle init.el
     ;;;;; Org-link-moinor-mode
     ;; (use-package org-link-minor-mode)
     (when (file-exists-p (format "%s/.emacs.d/org-link-minor-mode/org-link-minor-mode.el" MyHomeDir))
       (load-library (format "%s/.emacs.d/org-link-minor-mode/org-link-minor-mode.el" MyHomeDir)))

     (require 'org)
     (use-package org-link-minor-mode
       :ensure t)
   #+end_src

   Para más información [[https://github.com/seanohalpin/org-link-minor-mode][org-link-minor-mode]].

** Poporg

   Poporg es un paquete que permite hacer una correcta presentación de
   fragmentos de distintos modos dobre un mismo archivo, pudiendo mantener los
   modos generales de documentación integrando fragmentos de código en ellos
   para poder extraerlos posteriormente. Sirve principalmente para comentar de
   forma cómoda un código o añadir comentarios automaticamente.

   #+begin_src lisp :tangle init.el
     ;;;;; Poporg
     (use-package poporg
       :ensure t
       :bind
       ;; call it
       (:map global-map
         (("C-c SPC" . poporg-dwim))
         ;; from within the org mode, poporg-mode-map is a minor mode
         :map poporg-mode-map
         ("C-c C-c" . poporg-update)            ;; update original
         ("C-c SPC" . poporg-edit-exit)         ;; exit, keeping changes
         ("C-x C-s" . poporg-update-and-save))  ;; update original and save buffer
       :hook (poporg-mode . (lambda ()
                  (outline-show-all)
                  (aggressive-fill-paragraph-mode t)
                  (goto-char (point-min)))))
   #+end_src

   Para más información [[https://github.com/pinard/poporg][poporg]].

** Org-Trello

   Se trata de un paquete que permite la extensión del modo org a la herramienta
   trello disponible de forma gratuita en internet y nos permite realozar tareas
   de gestión de proyectos o tareas.

   #+begin_src lisp :tangle init.el
     ;;;;; Org Trello
     ;;(require 'org-trello)
     ;;(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
     ;;(package-initialize)

     ;;;;;; Set credentials
     ;; First of all you should connect with trello with the browser using next command:
     ;; org-trello-install-key-and-token
     ;; Now you can use trello woth emacs

     ;;;;;; Add Trello to major mode
     ;;(add-to-list 'auto-mode-alist '("\\.trello$" . org-mode))

     ;;;;;; Auto org-trello files in emacs
     ;;(add-hook 'org-mode-hook
     ;;(lambda ()
     ;;(let ((filename (buffer-file-name (current-buffer))))
     ;;(when (and filename (string= "trello" (file-name-extension filename)))
     ;;(org-trello-mode)))))
   #+end_src

   Para más información [[https://org-trello.github.io/][org-trello]].
** Company

   El modo company nos permite utilizar los desplegables para autocompletar
   palabras o funciones si es que estamos en un modo de programación en
   particular.

   #+begin_src lisp :tangle init.el
     ;;;; Company
     (use-package company
       :defer t
       :ensure t
       :init (global-company-mode t)
       :config
       ;; Company Quickhelp
       ;; When idling on a completion candidate the documentation for the
       ;; candidate will pop up after `company-quickhelp-delay' seconds.
       (use-package company-quickhelp
         :defer t
         :ensure t
         ;; :if window-system
         :init (company-quickhelp-mode t)
         :config
         (setq company-quickhelp-delay 0.2
           company-quickhelp-max-lines 10))
       ;; With use-package:
       ;; (use-package company-box
       ;;   :hook (company-mode . company-box-mode))
       ;; Variables
       (setq company-dabbrev-ignore-case nil
         company-dabbrev-code-ignore-case nil
         company-dabbrev-downcase nil
         company-idle-delay 0.01
         company-echo-delay 0.01
         company-minimum-prefix-length 2)
       :diminish company-mode)
   #+end_src

   Para más información [[http://company-mode.github.io/][company-mode]].

** Fly check

   Fly check es un paquete que permite la detección de errores en cada uno de
   los lenguajes de programación, subrayandolos y permitiendo sobre todo
   detectar errores de sintaxis, es muy útil cuando se programan en lenguajes
   interpretados.

   #+begin_src lisp :tangle init.el
     ;;;; Flycheck
     (use-package flycheck-pos-tip
       :defer t)
     (use-package helm-flycheck
       :defer t)
     (use-package flycheck-color-mode-line
       :defer t)
     (use-package flycheck
       :init
       (global-flycheck-mode t)
       (flycheck-pos-tip-mode t)
       :bind
       (:map flycheck-command-map
         ("h" . helm-flycheck))
       :config
       (setq flycheck-completion-system 'helm-comp-read )
       (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
   #+end_src

   Para más información [[https://www.flycheck.org/en/latest/][fly-check]].

** Aggresive indent

   Aggresive-indent es un paquete que permite mantener el estilo en función del
   modo de programación utilizado de forma que quede correctamente indentado, a
   veces es bueno quitarlo mientras se desarrolla ya que hay veces que
   desindenta el código hasta que esté terminada la línea. También permite la
   detección de errores en el código.

   #+begin_src lisp :tangle init.el
     ;;;; Aggresive indent
     (use-package aggressive-indent
       :init (global-aggressive-indent-mode 1))

     (use-package aggressive-fill-paragraph
       :ensure t)
   #+end_src

   Para más información [[https://github.com/Malabarba/aggressive-indent-mode][aggresive-indent]].

** Whitespace

   Este paquete permite eliminar los espacios en blanco no necesarios en
   cualquier código, esto permite una gran ayuda en la comparación y mantener
   los archivos sin exceso de carga.

   #+begin_src lisp :tangle init.el
     ;;;; Whitespace
     (use-package whitespace
       :config
       (add-to-list 'whitespace-style 'lines-tail)
       (setq-default show-trailing-whitespace nil)
       (setq whitespace-line-column 80))

     (use-package whitespace-cleanup-mode
       :init
       (global-whitespace-cleanup-mode 1)
       :config
       (setq whitespace-cleanup-mode-only-if-initially-clean nil))
   #+end_src

   Para más información [[https://github.com/emacs-mirror/emacs/blob/master/lisp/whitespace.el][whitespace]].

** Crux

   Este paquete incluye una colección de ridiculas cuncionalidades y
   extensiones, esto permite por ejemplo abrir archivos sin importar el nivel de
   privilegios con el que se accede y si es necesario lo reabre con uno superior.

   #+begin_src lisp :tangle init.el
     ;;;; Crux
     (use-package crux
       :defer t
       :config
       (progn
         (crux-reopen-as-root-mode 1))
       :bind
       (:map global-map
         ("C-a" . nil)
         ([remap kill-whole-line] . crux-kill-whole-line)
         ([remap move-beginning-of-line] . crux-move-beginning-of-line)
         ("C-a"  . crux-move-beginning-of-line)))

   #+end_src

   Para más información [[https://github.com/bbatsov/crux][crux]].

** Smart scan

   Smat scan permite buscar elementos, el uso que se le da en esta configuración
   es para desplazarnos entre palabras de un mismo buffer. Se utiliza a partir
   del Atl-p o Alt-n sobre una palabra para ir a la identica posterior o
   anterior.

   #+begin_src lisp :tangle init.el
     ;;;;  Smart scan
     (use-package smartscan
       :init
       (global-smartscan-mode 1)
       :bind
       (:map smartscan-map
         ("M-’" . 'smartscan-symbol-replace))
       :config
       ;; Variables
       (setq smartscan-symbol-selector "word"))
   #+end_src

   Para más información [[https://github.com/mickeynp/smart-scan][smart-scan]].

** Magit

   Magit es uno de los paquetes más importantes de esta configuración, nos
   permite poder utilizar git y git-snv desde el mismo emacs. Se accede a el a
   partir C-x g en una carpeta con un proyecto git para trabajar con ello y en
   una vacía para iniciarlo. Básico para el control de versiones de cualquier
   proyecto.

   #+begin_src lisp :tangle init.el
     ;;;; Magit
     (use-package magit-svn
       :ensure t)

     (use-package magit
       :config
       (add-hook 'magit-mode-hook 'magit-svn-mode)
       (setq magit-diff-paint-whitespace nil
         magit-diff-highlight-trailing nil
         magit-refresh-verbose t
         magit-refresh-status-buffer t
         magit-display-buffer-function
         #'magit-display-buffer-fullframe-status-v1
         magit-diff-highlight-indentation nil))
   #+end_src

   Para más información [[https://magit.vc/][magit]] y [[https://magit.vc/][magit-svn]].

** Super Save

   Este módulo permite la configuración del autoguardado de las fuentes
   modificadas. también se instala super save para que gruarde el buffer
   automáticamnte cada vez que se cambie de buffer.

   #+begin_src lisp :tangle init.el
     ;;;; Auto backup and save
     (setq auto-save-default t	;; do auto-saving of every file-visiting buffer.
           delete-auto-save-files t  ;; delete auto-save file when a buffer is saved or killed.
           auto-save-timeout 10	;; Number of seconds idle time before auto-save.
           auto-save-interval 300)	;; Number of input events between auto-saves.

     (use-package super-save
       :init
       (super-save-mode 1)
       :defer 5
       :config
       (setq super-save-auto-save-when-idle t ;; Save current buffer automatically when Emacs is idle
         super-save-remote-files nil)     ;; Save remote files when t, ignore them otherwise
       )
   #+end_src

   Para más información [[https://github.com/bbatsov/super-save][super-save]].

** Which key

   Se trata de un paquete que permite generar una ayuda de autocompletar los
   distintos comandos mientras se escriben, se utiliza por ejemplo en paquetes
   como projectile cuando tenemos una gran variedad de comandos para mostrar que
   hace cada combinación.

   #+begin_src lisp :tangle init.el
     ;;;; Which key
     (use-package which-key
       :init (which-key-mode 1)
       :pin melpa-stable
       :ensure t
       :config
       ;; Set the time delay (in seconds) for the which-key popup to appear.
       (setq which-key-idle-delay 0.5)
       ;; A list of regexp strings to use to filter key sequences.
       (setq which-key-allow-regexps '("C-c p" "C-c p s" "C-x c"))
       ;; Set the maximum length (in characters) for key descriptions (commands or
       ;; prefixes). Descriptions that are longer are truncated and have ".." added
       (setq which-key-max-description-length nil)
       ;; Set the separator used between keys and descriptions. Change this setting to
       ;; an ASCII character if your font does not show the default arrow. The second
       ;; setting here allows for extra padding for Unicode characters. which-key uses
       ;; characters as a means of width measurement, so wide Unicode characters can
       ;; throw off the calculation.
       (setq which-key-separator " → " )
       (setq which-key-unicode-correction 3)
       (setq which-key-max-display-columns 3)
       ;; Set the special keys. These are automatically truncated to one character and
       ;; have which-key-special-key-face applied. Set this variable to nil to disable
       ;; the feature
       (setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL"))
       ;; Show the key prefix on the left or top (nil means hide the prefix). The
       ;; prefix consists of the keys you have typed so far. which-key also shows the
       ;; page information along with the prefix.
       (setq which-key-show-prefix 'left)
       ;; Set to t to show the count of keys shown vs. total keys in the mode line.
       (setq which-key-show-remaining-keys nil))
   #+end_src

   Para más información [[https://github.com/justbur/emacs-which-key][which-key]].

** Which function

   Permite hacer lo mismo que el paquete anterior pero sobre la escritura de
   funciones en ciertos modos mayores.

   #+begin_src lisp :tangle init.el
     ;;;; Which function
     (use-package which-func
       :init
       (which-function-mode 1)
       :config
       (setq which-func-unknown " "
         which-func-format
         (list " " (car (cdr which-func-format)) "")
         mode-line-misc-info
         ;; We remove Which Function Mode from the mode line, because it's mostly
         ;; invisible here anyway.
         (assq-delete-all 'which-func-mode mode-line-misc-info))
       (setq-default header-line-format '((which-function-mode (""
             which-func-format " ")))))
   #+end_src

   Para más información [[https://www.emacswiki.org/emacs/WhichFuncMode][which-function]].

** Autocompile

   Este paquete permite realizar la auticompilación de los archivos el que se
   descargan en la instalación para que estén automáticamente disponibles para
   su uso en su última versión.

   #+begin_src lisp :tangle init.el
     ;;;; Autocompile
     (use-package auto-compile
       :init
       (auto-compile-on-load-mode 1)
       (auto-compile-on-save-mode 1)
       :config
       (setq auto-compile-display-buffer nil
             auto-compile-mode-line-counter t
             load-prefer-newer t
             auto-compile-display-buffer nil
             auto-compile-mode-line-counter t))
   #+end_src

   Para más información [[https://github.com/emacscollective/auto-compile][auto-compile]].

** Multiple cursors

   Permite la generación de multiples cursores para editar texto en columna para
   aumentar la velocidad en el desarrollo. Para utilizarlo es necesario marcar
   las distintas líneas sobre las que se quiere actuar y luego proceder con /C-c
   m c/

   #+begin_src lisp :tangle init.el
     ;;;; Multiple cursors
     (use-package multiple-cursors)
     (global-set-key (kbd "C-c m c") 'mc/edit-lines)
   #+end_src

   Para más información [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]].

** TODO Yasnippet

   Se trata de un paquete de gestión de snippets o fragmentos de código a los
   que se invoca a partir de un nombre en clave y su ejecución con el tambulador.

   #+begin_src lisp :tangle init.el
     ;;;; Yasnippet
     (use-package yasnippet)
     ;; Use as global mode
     (yas-global-mode 1)
     ;;;;; Add yasnippet as minor mode in prog-modes
     ;;(yas-reload-all)
     ;;(add-hook 'prog-mode-hook #'yas-minor-mode)
     ;;;;; Configure yasnippet
     (setq yas-snippet-dirs
           '("~/.emacs.d/snippets/vhdl-mode/vhdl"
     ;;	"~/.emacs.d/snippets/C"
        ))
     ;;;;; Create snippets
     ;; look in noxt folder .emacs/elpa/yasnippet-snippets/snippets/vhdl-mode/
   #+end_src

   Para más información [[https://github.com/joaotavora/yasnippet][yasnippet]].

** Annotation mode

   El modo anotación nos permite tomar notas sobre un archivo sin modificar el
   original, creando otro en el que se almacene el original más las notas. Muy
   útil al coger el proyecto de otra persona y querer mantener el proyecto
   comprendiendolo antes de empezar a trabajar con el.

   #+begin_src lisp :tangle init.el
     ;;;; Annotation mode
     (defun csb/org-annotate-file ()
       (interactive)
       (let ((org-annotate-file-add-search t)
             (org-annotate-file-storage-file
              (if (buffer-file-name) ;; if not nil
                  ;; for the rest of buffers, create a hidden folder containing its buffer-file-name
                  (concat (file-name-directory (buffer-file-name)) "." (file-name-nondirectory (buffer-file-name))
                          ".annotations")
                "~/.org-annotate-file.org")))
         (org-annotate-file)))

     (global-set-key (kbd "C-c C-SPC") #'csb/org-annotate-file)
   #+end_src

   Para más información [[https://www.emacswiki.org/emacs/OrgAnnotateFile][annotation-mode]].

** Ispell-mode

   Permite poder utilizar un corrector de texto en distintos lenguajes al
   utilizar el modo texto. revisar con ispell y aspell. Para poder utilizar el
   corrector es importante instalar previamente los diccionarios de idiomas a
   utilizar, en mi caso utilizaré el español y el inglés. Para ello se define el
   diccionario y luego se puede seleccionar el buffer y aplicar /ispell-region/.

   Yo lo uso con /M-x ispell-continue/ y saltando a la siguiente palabra pulsando
   el /SPC/.

   #+begin_src lisp :tangle init.el
     (setq-default ispell-program-name "aspell")
     (setq ispell-dictionary "castellano")
     (setq ispell-local-dictionary. "castellano")
     (flyspell-mode 1)
   #+end_src

   Para más información [[https://gist.github.com/Ondiz/2fba1c143cd9d8682ea358082a202f1d][hunspell]].

** Helm

   Help nos permite realizar una búsqueda y autocompletar los comandos de lisp
   integrando distintas herramientas de búsqueda como las cargadas en los
   siguientes paquetes.

   #+begin_src lisp :tangle init.el
     (use-package helm
       :init
       (require 'helm-config)
       (helm-mode 1)
       (helm-autoresize-mode 1)
       :config
       (helm-autoresize-mode 1)
       (global-set-key (kbd "M-x")     'helm-M-x)
       (global-set-key (kbd "C-x C-b") 'helm-buffers-list)
       (global-set-key (kbd "C-x b")   'helm-mini)
       (global-set-key (kbd "C-x C-f") 'helm-find-files)
       (define-key helm-command-map (kbd "T") #'helm-themes)
       (global-set-key (kbd "M-y")     'helm-show-kill-ring))
   #+end_src

   Para más información [[https://github.com/emacs-helm/helm][helm-package]].

** Project management

   Para la gestión de proyectos, sobre todo proyectos grandes en los que podemos
   encontrar una gran variedad de fuentes y carpetas es recomendable utilizar
   /projectile/ que permite el uso de muchas funcionalidades que resultan
   básicas una vez te has acostumbrado a ellas. Se utiliza en combinación con
   /helm/ para busquedas específicas dentro del proyecto.

   #+begin_src lisp :tangle init.el
     ;;;; Projectile
     (use-package projectile
       :init (projectile-mode 1)
       :ensure t
       :pin melpa-stable
       ;; Keys
       :bind
       (:map projectile-mode-map
         ("C-c p" . projectile-command-map)
         ("C-c p s a" . projectile-ag)
         ("C-c p s s" . nil))
       :config

       ;; Variables
       (setq projectile-completion-system 'helm
         projectile-indexing-method 'native
         projectile-enable-caching t
         projectile-remember-window-config t
         projectile-switch-project-action 'projectile-dired)

       (add-to-list 'projectile-globally-ignored-directories ".backups")
       (add-to-list 'projectile-globally-ignored-directories ".stversions"))

     ;; Helm + projectile
     (use-package helm-projectile
       :init (helm-projectile-on)
       :ensure t
       :pin melpa-stable
       :config
       (setq
        helm-projectile-fuzzy-match t
        helm-projectile-sources-list '(helm-source-projectile-recentf-list
                       helm-source-projectile-buffers-list
                       helm-source-projectile-files-list
                       helm-source-projectile-projects)))
   #+end_src

   Para más información [[https://github.com/bbatsov/projectile][projectile]] y [[https://github.com/bbatsov/helm-projectile][helm-projectile]].

** Helm-ag (Grep)

   Permite a emacs utilizar herramientas específicas de búsqueda de linux.

   #+begin_src lisp :tangle init.el
     ;;;; Grep
     (use-package helm-ag
       :ensure t)
   #+end_src

   Para más información [[https://github.com/emacsorphanage/helm-ag][helm-ag]].

** Ripgrep

   Usa projectile para realizar búsquedas dentro de un proyecto.

   #+begin_src lisp :tangle init.el
     ;;;; Ripgrep
     (use-package ripgrep
       :ensure t)
   #+end_src

   Para más información [[https://github.com/nlamirault/ripgrep.el][ripgrep-package]].

** Helm-rg (Rg)

   Permite la gestión para búsquedas masivas de datos.

   #+begin_src lisp :tangle init.el
     ;;;; Ag
     (use-package helm-rg
       :ensure t
       :pin melpa-stable)
   #+end_src

   Para más información [[https://github.com/cosmicexplorer/helm-rg][helm-rg]].

** TODO Wakatime

   Wakatime es un paquete que permite evaluar la eficiencia de tu uso de emacs,
   evaluando el tipo de scripts que habitualmente utilizas y el tiempo consumido
   en la modificación de los mismos. Utiliza un paquete externo que permite la
   visualización de los datos obtenidos a través de web. Lo mantego comentado
   hasta poder solucionar los problemas encontrados.

   #+begin_src lisp :tangle init.el
     ;;;; Wakatime
     ;;(use-package wakatime-mode)
     ;;(global-wakatime-mode 1)
   #+end_src

   Para más información [[https://wakatime.com/emacs][wakatime-package]] y [[https://github.com/wakatime/wakatime][wakatime-tool]].

** Undo-tree

   Este paquete permite navegar a traves de los cambios realizados en el archivo
   facilmente, evitando tener que utilizar los metodos de deshacer cambios
   complejos e inútiles del propio editor.

   #+begin_src lisp :tangle init.el
     ;;;; Undo tree
     (use-package undo-tree)
     ;; Active as global mode
     (global-undo-tree-mode 1)
   #+end_src

   Para más información link

** Mode-icons

   Permite visualizar los iconos o imagenes de las miniaturas en función del
   archivo que se tenga abierto.

   #+begin_src lisp :tangle init.el
     ;;;; Mode icons
     (use-package mode-icons)
     (mode-icons-mode)
   #+end_src

   Para más información [[https://github.com/ryuslash/mode-icons][mode-icons]].

** Hightlight-symbol

   Se trata de un paquete que permite el subrayado de una palabra o código
   manteniendolo subrayado mientras navegas por el fichero para detectar donde
   se repite.

   #+begin_src lisp :tangle init.el
     ;;;; Hightlight-symbol
     (use-package highlight-symbol)
     (global-set-key [(control f3)] 'highlight-symbol)
     (global-set-key [f3] 'highlight-symbol-next)
     (global-set-key [(shift f3)] 'highlight-symbol-prev)
     (global-set-key [(meta f3)] 'highlight-symbol-query-replace)
   #+end_src

   Para más información [[https://github.com/nschum/highlight-symbol.el][highlight-symbol]].

** Google this

   Se trata de un paquete que permite realizar búsquedas desde emacs.

   #+begin_src lisp :tangle init.el
     ;; Install package
     (use-package google-this)
     ;; Set active
     (google-this-mode 1)
   #+end_src

   Para más información [[https://github.com/Malabarba/emacs-google-this][google-this]].

** Google translator

   Paquete que permite poder realizar traducciones a partir del uso de google
   translate.

   #+begin_src lisp :tangle init.el
     (use-package google-translate)
     (require 'google-translate-smooth-ui)
     (global-set-key "\C-ct" 'google-translate-smooth-translate)
   #+end_src

   Para más información [[https://github.com/atykhonov/google-translate][google-translate]].

** Texto

   Descripción

   #+begin_src lisp :tangle init.el
   #+end_src

   Para más información Link

* Global features

  Los siguientes apartados permiten la gestión de la apariencia y uso general de
  emacs como herramienta, en el se definen distintos comandos generales que
  utilizar desde cualquier punti, como las funcionalidades generales
  implementacas, se incluyen aspectos como la apariencia respecto a usuario y de
  las fuentes respecto al SO utilizado.

   #+begin_src lisp :tangle init.el
     ;;; Global features
   #+end_src

** Global keys

   Estos son comandos que permiten el uso de distintos elementos de forma
   global, es decir, independientemente del modo de trabajo en el que estemos.

   #+begin_src lisp :tangle init.el
     ;;;; Global keys
     ;; Cambia la fuente del buffer a su valor por defecto.
     (global-set-key (kbd "C-=") (lambda () (interactive) (text-scale-adjust 0)))
     ;; Maximiza las fuentes del buffer
     (global-set-key (kbd "C-+") (lambda () (interactive) (text-scale-increase 0.5)))
     ;; Minimiza las fuentes del buffer
     (global-set-key (kbd "C--") (lambda () (interactive) (text-scale-decrease 0.5)))
     ;; Cierra el buffer activo
     (global-set-key (kbd "C-x k") #'kill-this-buffer)
     ;; Abre magit mostrando el estado de la carpeta
     (global-set-key (kbd "C-x g") #'magit-status)
   #+end_src

** Global variables

   En este apartado se modifica parte de la funcionalidad general a partir de la
   selección de los valores de ciertas variables seleccionadas por defecto.

   #+begin_src lisp :tangle init.el
     ;;;; Global variables
     (setq-default
      confirm-kill-emacs nil
      inhibit-splash-screen t
      inhibit-startup-message t
      ad-redefinition-action 'accept                   ; Silence warnings for redefinition
      confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
      cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
      delete-by-moving-to-trash t                      ; Delete files to trash
      display-time-default-load-average nil            ; Don't display load average
      display-time-format "%H:%M"                      ; Format the time string
      fill-column 80                                   ; Set width for automatic line breaks
      help-window-select t                             ; Focus new help windows when opened
      indent-tabs-mode nil                             ; Stop using tabs to indent
      inhibit-startup-screen t                         ; Disable start-up screen
      initial-scratch-message ""                       ; Empty the initial *scratch* buffer
      left-margin-width 1 right-margin-width 1         ; Add left and right margins
      mode-require-final-newline 'visit                ; Add a newline at EOF on visit
      mouse-yank-at-point t                            ; Yank at point rather than pointer
      ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
      recenter-positions '(5 top bottom)               ; Set re-centering positions
      redisplay-dont-pause t                           ; don't pause display on input
      debug-on-error t
      jit-lock-defer-time 0
      frame-resize-pixelwise t
      fast-but-imprecise-scrolling t
      scroll-conservatively 10000                      ; Always scroll by one line
      scroll-margin 1                                  ; scroll N lines to screen edge
      scroll-step 1                                    ; keyboard scroll one line at a time
      scroll-preserve-screen-position 1
      select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
      sentence-end-double-space nil                    ; End a sentence after a dot and a space
      show-trailing-whitespace nil                     ; Display trailing whitespaces
      split-height-threshold nil                       ; Disable vertical window splitting
      split-width-threshold nil                        ; Disable horizontal window splitting
      tab-width 4                                      ; Set width for tabs
      uniquify-buffer-name-style 'forward              ; Uniquify buffer names
      window-combination-resize t                      ; Resize windows proportionally
      x-stretch-cursor t)                              ; Stretch cursor to the glyph width
   #+end_src

   Para más información link

** Global modes

   Este apartado permite la configuración de las funcionalidades básicas por
   defecto que tendrá emacs al abrirse.

   #+begin_src lisp :tangle init.el
     ;;;; Global modes
     (delete-selection-mode)                           ; Replace region when inserting text
     (setq line-number-mode t)                         ; Enable line numbers in the mode-line
     (setq column-number-mode t)                       ; Enable column numbers in the mode-line
     (size-indication-mode 1)                          ; Enable size status in the mode-line
     (display-time-mode)                               ; Enable time in the mode-line
     (when (window-system)
       (fringe-mode 80))
     (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
     (global-hl-line-mode)                             ; Hightlight current line
     (show-paren-mode t)
     (setq show-paren-style 'expression)
     (global-subword-mode)                             ; Iterate through CamelCase words
     (menu-bar-mode 0)                                 ; Disable the menu bar
     (mouse-avoidance-mode 'banish)                    ; Avoid collision of mouse with point
     (put 'downcase-region 'disabled nil)              ; Enable downcase-region
     (put 'upcase-region 'disabled nil)                ; Enable upcase-region
     (put 'downcase-region 'disabled nil)              ; Enable downcase-region
     (put 'upcase-region 'disabled nil)                ; Enable upcase-region
     (add-hook 'focus-out-hook #'garbage-collect)
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
     (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src

** Encoding

   La codificación de las fuentes es una característica importante por ello se
   busca un sistema de codificación estandar como es /utf8/.

   #+begin_src lisp :tangle init.el
     (set-language-environment 'utf-8)
     (setq locale-coding-system 'utf-8-unix)
     (prefer-coding-system 'utf-8-unix)
     (set-default-coding-systems 'utf-8-unix)
     (set-terminal-coding-system 'utf-8-unix)
     (set-keyboard-coding-system 'utf-8-unix)
     (set-selection-coding-system 'utf-8-unix)
   #+end_src

   Para más información [[https://es.wikipedia.org/wiki/UTF-8][utf-8]].

** Theme

   Aquí se realiza la descarga del paquete de gruvbox que permite el uso de sus
   6 temas distintos, a mi me gusta el /dark-hard/ para por la noche y el
   /ligth-soft/ para el día. Para poder trabajar con los dos modos utilizo el
   paquete /adaptative-theme/ para el uso combinado de temas claros y oscuros en
   función del cambio horario de mi localización.

   #+begin_src lisp :tangle init.el
     ;;;; Theme
     ;;;;; Adaptative theme installation
     (when (file-exists-p (format "%s/.emacs.d/adaptative-theme/adaptativeTheme.el" MyHomeDir))
       (load-file (format "%s/.emacs.d/adaptative-theme/adaptativeTheme.el" MyHomeDir)))

     (adaptative-theme-autolocation 'gruvbox-light-soft 'gruvbox-dark-hard)
   #+end_src

   Para más información [[https://github.com/greduan/emacs-theme-gruvbox][gruvbox-theme]] and [[https://github.com/alvarocsm91/adaptative-theme][adaptative-theme]].
